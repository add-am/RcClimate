---
title: "Climate: Land Use"
subtitle: "A Healthy Waters Partnership Analysis"
description: "This script analyses and presents land use data in the Northern Three reporting regions. The output of this is used in the Northern Three technical reports."
author: "Adam Shand" 
format: html
params: 
  project_crs: "EPSG:7844"
  target_fyear: 2024
---

# Introduction

This script contains the methods used to wrangle, analyse and present land use data in the Northern Three regions. For a guide on downloading land use data refer to the README document for the Spatial Analysis GitHub repo. Note that the data for this script requires an additional step of pre-processing using QGIS.

Land use data is predominantly used within the climate section of the technical report to "set the scene" for each basin in each region. Land use is currently not scored, and is only a contextual dataset. The main objectives of this script are to:

- Create tabular summaries of the types of land use present in each basin.
- Create a plot of different land use types as a proportion of the basin.
- Create maps of land use types in each basin.

# Script Set Up

This script requires multiple core spatial packages, each of which is loaded below. Key variables and paths are also created.

```{r}
#| label: load packages

#use pacman function to load and install (if required) all other packages
pacman::p_load(tidyverse, glue, here, janitor, sf, tmap, exactextractr, terra, RColorBrewer, ggplot2)

#set project variables: crs factor and current_fyear
proj_crs <- params$project_crs
fac <- params$disagg_factor
current_fyear <- params$target_fyear

#load in the custom function used to create the read and write folders for the script
source(here("functions/script_setup.R"))

#run the function to create the folders and paths
script_setup()

#read in the custom function to clean column names into our specific style
source(here("functions/name_cleaning.R"))

```

# Load Data

Now the script is set up we need to load in all of the required datasets. This will be broken into two segments:
- Spatial data specific to the N3 region - such as the region, basin, and sub basin boundaries.
- Land use data

## Spatial Data

Spatial data for the northern three regions should be readily available in the repo, the dataset is created by the n3_region-builder.qmd script in the repo that should be the first script run for new users. If the dataset is not available refer back to the README document in the GitHub repo. The other parts of spatial data here should go off without a hitch if the region-builder script has been run.

```{r}
#| label: load the n3 region

#select only the land components of the n3 region dataset
n3_land <- n3_region |> 
  filter(Environment != "Marine") |> 
  group_by(Region, BasinOrZone, SubBasinOrSubZone) |> 
  summarise(geometry = st_union(geom)) |> 
  ungroup() |> st_cast()

```

## Land Use

For the N3 region we require multiple large datasets (e.g. across the entirety of Queensland) that can take a while to process. The first time these code chunks are run they will read in each of the land use datasets, perform the editing steps, and then save the output. The next time the code chunks are run they will check if the edited version exists, and open that instead. This dramatically reduces processing time on repeat runs of the script.

:::{.callout-note}
If for some reason you find that the edited output is not what you want, or that you need to re-run the original code chunks you will need to edit the code chunk to not allow the edited version to be opened. Or delete the edited version from the directory.

For example, if new datasets are published to QSpatial you will need to rerun the original merge and crop step.
:::

This first code chuck handles exotic geometries present in the data (this seems to be the only type of data across the whole repo that requires this step). The code:
- Opens each file and seperates the exotic geometries from the standard geometries.
- Saves the exotics to their own (temporary) file and edits this exotics file using gdalUtils.
- Reads the edited exotics file back into R and combines it with the standard geometries.

Exotic geometries and those that are a bit rarer (e.g. MULTISURFACE, CURVELINEAR), whereas standard geometries are the ones everyone should be familiar with (POLYGON, LINE, POINT).

```{r}
#| label: data processing
#| output: false

if (file.exists(glue("{data_path}/processed/n3_land_use_clean.gpkg"))) {#if the full version exists
  
  #open the full version
  n3_land_use_clean <- st_read(glue("{data_path}/processed/n3_land_use_clean.gpkg")) |>  
    name_cleaning()
    
} else {#otherwise
  
  #initialize an empty df to store the output
  n3_land_use_clean <- data.frame()
  
  #get all gpkg files with years in name (ignores the original mwi file).
  file_names <- list.files(glue("{data_path}/raw/"), pattern = ".[[:digit:]]\\.gpkg") 
  
  for (i in 1:length(file_names)){#for each of the files in the list
    
    #pull the year from the file name
    year <- str_extract(file_names[i], "1999|2009|2015|2016|2021")
    
    #read in each file 
    temp_sf <- st_read(glue("{data_path}/raw/{file_names[i]}")) |> 
      select(matches("Primary|Secondary|Tertiary")) |> 
      rename_with(~str_remove_all(., "[0-9]|_"), matches("Primary|Secondary|Tertiary")) |> 
      mutate(Year = year)
    
    #and separate the data into "standard" geometries - polygons, and non-standard geometries - e.g. multisurfaces
    standard_geoms <- temp_sf |> filter(grepl("POLYGON", st_geometry_type(geom))) |> st_make_valid()
    non_standard_geoms <- temp_sf |> filter(grepl("MULTISURFACE", st_geometry_type(geom)))
    
    #save non-standard geoms to be edited
    st_write(non_standard_geoms, glue("{data_path}/temporary_storage.gpkg"), delete_dsn = T)
    
    #use the gdalUtilies to open edit and save the file (it auto saves as a folder containing a shapefile)
    gdalUtilities::ogr2ogr(glue("{data_path}/temporary_storage.gpkg"), glue("{data_path}/temporary_storage"), 
                           explodecollections = T, nlt = 'CONVERT_TO_LINEAR', overwrite = T)
    
    #read back in the edited file
    fixed_geoms <- st_read(glue("{data_path}/temporary_storage/temporary_storage.shp")) |> 
      rename(geom = geometry) |> st_make_valid()
    
    #join the fixed data onto the standard data
    temp_sf <- rbind(standard_geoms, fixed_geoms)
    
    #join the dataset to the main dataset
    n3_land_use_clean <- rbind(n3_land_use_clean, temp_sf)
    
  }
  
  #clean up data
  rm(file_names, fixed_geoms, standard_geoms, non_standard_geoms, temp_sf, year)
  unlink(glue("{data_path}/temporary_storage/"), recursive = T)
  unlink(glue("{data_path}/temporary_storage.gpkg"))
}
 
```

After all the exotic geometries have been taken care of, the newly combined data needs to restricted to the N3 region to improve processing time, and categories into the land use types that we are interested in. Land use data is broken down into land use types at multiple levels (primary, secondary and tertiary). Primary is the broadest level, and tertiary is the most precise level. 

Throughout the life of the partnership the opinions and requirements about the different land use types has changed and evolved. Given this, we will first save a "clean" version of the dataset - where no changes or groupings have been made regarding landuse types, and the only modification is the spatial restriction to the N3 region.

```{r}
#| label: data processing step 2

if (file.exists(glue("{data_path}/processed/n3_land_use_clean.gpkg"))) {#if the edited version exists
  
  #do nothing because the below edits have already occurred.
  
} else {#otherwise 
  
  #add region, basin, sub basin context, then remove small amounts of overlap for dt and wt
  n3_land_use_clean <- st_intersection(n3_land_use_clean, n3_land) |> 
    filter(!Region %in% c("Dry Tropics", "Burdekin") | Year != "2015",
           Region != "Wet Tropics" | Year != "2016")
  
  #make sure all entries are fully lower case - helps us filter
  n3_land_use_clean <- n3_land_use_clean |> 
    mutate(across(matches("Primary|Secondary|Tertiary"), str_to_lower))
  
  #save the output
  st_write(n3_land_use_clean, glue("{data_path}/processed/n3_land_use_clean.gpkg"), delete_layer = T)
  
}

```

Following this, we will combine the dataset into what is currently accepted as the broadest level of classification. Noting that in the future, or for side projects, we can simply revert to the "clean" version rather than having to go completely back to square one.

Generally we are not concerned with the difference between for example; "National Park" and "Natural Feature Protection" (a tertiary level separation). Therefore we will only breakdown and report on land use at a custom mix of the primary and secondary land use type levels. These levels are as follows:

 - "Conservation"
 - "Dryland Agriculture"
 - "Forestry"
 - "Grazing"
 - "Irrigated Agriculture"
 - "Mining"
 - "Urban/Intensive"
 - "Water"

For information on what each of these classifications encompasses refer to the README for links to additional information.

```{r}
#| label: data processing step 3

if (file.exists(glue("{data_path}/processed/n3_land_use_grouped.gpkg"))) {#if the edited version exists
  
  #open the grouped version
  n3_land_use_grouped <- st_read(glue("{data_path}/processed/n3_land_use_grouped.gpkg")) |>  
    name_cleaning()
  
} else {#otherwise 

  #edit entries to create groupings we want
  n3_land_use_grouped <- n3_land_use_clean |> 
    select(-Tertiary) |> 
    mutate(Landuse = case_when(str_detect(Primary, "water") ~ "water",
                               str_detect(Primary, "conservation") ~ "conservation",
                               str_detect(Primary, "irrigated") ~ "irrigated agriculture",
                               str_detect(Primary, "dryland") ~ "dryland agriculture",
                               str_detect(Primary, "relatively natural") ~ "grazing",
                               str_detect(Primary, "intensive") ~ "urban/intensive",
                               T ~ Secondary)) |> 
    mutate(Landuse = case_when(str_detect(Secondary, "grazing") ~ "grazing", 
                               str_detect(Secondary, "forest") ~ "forestry",
                               str_detect(Secondary, "mining") ~ "mining", 
                               T ~ Landuse)) |> 
    select(-c(Primary, Secondary))
  
  #save the output
  st_write(n3_land_use_grouped, glue("{data_path}/processed/n3_land_use_grouped.gpkg"), delete_layer = T)
  
}

```

# Analyse Data

Now the data is sorted, imported, and ready to be reported, we can move onto calculating some statistics. Below we calculate:

 - The total area of each region each year (varies very slightly year on year)
    + The area of each landuse type in each region each year
    + The proportion of each landuse type relative to the entire region area each year
    + The area change of each landuse type from year to year (i.e. if 1999 = 2km, and 2009 = 3km, area change = 1km)
    + The percentage change of each landuse type from year to year (i.e. area change = 1km (and 1999 = 2km), percent change = 50%)

The above calculations are then repeated for every basin, and then repeated again for every sub basin.

:::{.callout-note}
Currently there is no defined "nice" way that we have elected to present this data, so we are simply saving all the data in one table. However, in the future we may be able to define the format in which we want to present, and exactly what data is needed.
:::

```{r}
#| label: Proportional Land Use

#calculate the area of every single row, then group up and sum areas for each group
n3_land_use_tbl <- n3_land_use_grouped |> 
  mutate(LanduseArea = st_area(geom)) |> st_drop_geometry() |> 
  group_by(Landuse, Region, BasinOrZone, SubBasinOrSubZone, Year) |> 
  summarise(LanduseArea = sum(LanduseArea)) |> ungroup()

#update the units to a more reasonable metric
n3_land_use_tbl$LanduseAreaKm2 <- units::set_units(n3_land_use_tbl$LanduseArea, km^2)

#drop the original area (m)
n3_land_use_tbl <- n3_land_use_tbl |> dplyr::select(-any_of("LanduseArea"))

#create three different vectors to be used as a grouping and a similar list for removing columns
cols_to_pick <- list(c("Region"), c("Region", "BasinOrZone"), c("Region", "BasinOrZone", "SubBasinOrSubZone"))
cols_to_remove <- list(c("BasinOrZone", "SubBasinOrSubZone"), c("SubBasinOrSubZone"), c(""))

#create an empty df to store the output
n3_land_use_final <- data.frame()

#for each of the grouping vectors
for (i in 1:length(cols_to_pick)){
  
  #calculate everything (i.e. do the math at a region level, a basin level, and a sub basin level)
  temporary_table <- n3_land_use_tbl |> 
    group_by(across(.cols = c(cols_to_pick[[i]], Year))) |> #group at year + region, then next loop at year + basin, then next loop, etc.
    mutate(TotalAreaKm2 = sum(LanduseAreaKm2)) |> #get the total area for the group
    group_by(across(.cols = c(cols_to_pick[[i]], Landuse, Year))) |> #do the same group, including landuse type
    mutate(LanduseKm2 = sum(LanduseAreaKm2), #get the area of the year + landuse + region/basin/sub basin
           LanduseProportionOfTotalPercent = (LanduseKm2/TotalAreaKm2)*100) |> #get the proportion of the landuse vs the total area
    dplyr::select(-any_of(c(cols_to_remove[[i]], "LanduseAreaKm2"))) |> #remove cols not used in the original grouping
    distinct() |> 
    group_by(across(.cols = c(cols_to_pick[[i]], Landuse))) |> #group at land use + region/basin/or sub basin (ignore year)
    mutate(across(LanduseKm2, as.numeric), #force area to be a numerical value for calculations below
           AreaChangeYearToYear = (LanduseKm2 - lag(LanduseKm2)), #calculate the difference between each row (year) as km2
           PercentageChangeYearToYear = (LanduseKm2/lag(LanduseKm2) -1) *100, #calculate the difference as %
           XyearToXyear = paste(Year, lag(Year), sep = " to "), #create column explain what years were compared
           XyearToXyear = case_when(str_detect(XyearToXyear, "NA") ~ "1999 to 1999", #edit to fix when there is no "row above"
                                      T ~ XyearToXyear),
           across(where(is.numeric), ~replace_na(., 0)), #replace na area and % change values with zero
           across(where(is.numeric), round, 1)) |> ungroup()
  
  #join to main
  n3_land_use_final <- bind_rows(n3_land_use_final, temporary_table)

}

#reorder cols
n3_land_use_final <- n3_land_use_final |> 
  relocate(Region, BasinOrZone, SubBasinOrSubZone)

#save the output
write_csv(n3_land_use_final, glue("{output_path}/land_use_full_table.csv"))

```

# Visualise Land Use

We can now visualise land use, using both plots and graphs. 

## Mapping Land Use

Currently we are presenting land use maps for:

 - Each sub basin in each region: DT(12), Burdekin (6), --> 18
 - Each basin in each region: DT(2), WT(9), MWI(5), Burdekin (2), --> 18
 - Each region overall (DT, WT, MWI, Burd), --> 4
 - and, Across every year: (which is currently 1999, 2009, 2015/2016 and 2021). --> 4

for a total of (18+18+4)*4 = 160 maps.

First we will prep the data and make sure all the correct colours are assigned.

```{r}
#| label: prep colours

#create a named colour palette
my_palette <- c("conservation" = "#277402", 
                "dryland agriculture" = "#948A54", 
                "forestry" = "#4EE703",
                "grazing" = "#FFFFBF", 
                "irrigated agriculture" = "#D0FF73", 
                "mining" = "#632523",
                "urban/intensive" = "#FF5704", 
                "water" = "#4F81BD")

#update the dataset by calling the palette colours using the landuse column in the df
n3_land_use_grouped <- n3_land_use_grouped |> 
  mutate(Palette = my_palette[Landuse])
  
```

Then we will create a list contains name vectors of targets. Essentially providing us with the name of the column to filter (region, basin, sub_basin), and the name of the location to look for (e.g. Black, Ross, Haughton).

```{r}
#| label: get list of targets

#get vectors of sub_basins, basins, and regions 
sub_basin_targets <- unique(n3_land_use_grouped$SubBasinOrSubZone)
basin_targets <- unique(n3_land_use_grouped$BasinOrZone)
region_targets <- unique(n3_land_use_grouped$Region)

#if the sub basin target exists in the basin list, remove it (as it is a duplicate)
sub_basin_targets <- sub_basin_targets[!sub_basin_targets %in% basin_targets]

#and combine into a list of named vectors
all_targets <- list("SubBasinOrSubZone" = sub_basin_targets, "BasinOrZone" = basin_targets, "Region" = region_targets)

```

Using this list of targets we can loop over the dataset to create each map.

```{r}
#| label: create the maps

#load in a custom function to create the water layer
source(here("functions/maps_water_layer.R"))
source(here("functions/maps_inset_layer.R"))

#start mapping loop
for (i in 1:length(all_targets)){#for the number of vectors that are in the list (3)

  for (j in 1:length(all_targets[[i]])){#and for the number of variables that are in the vector
    
    #specify both the column to filter on, and the variable to look for
    target_data <- n3_land_use_grouped |> filter(!!sym(names(all_targets[i])) == all_targets[[i]][j])
    target_outline <- n3_land |> filter(!!sym(names(all_targets[i])) == all_targets[[i]][j])
    
    #figure out the wider region in which the target is within
    target_region <- n3_land |> filter(Region == unique(target_outline$Region))
    
    #create a folder to store outputs at a regional level
    dir.create(glue("{output_path}/maps/{unique(target_region$Region)}/"))
    
    #run the custom water map function, pick which method based on if its region, basin, or sub basin
    if (i == 1){maps_water_layer(target_outline, stream_order = 2, fast = T, 
                     sub_basin_or_sub_zone = all_targets[[i]][j])}
    if (i == 2){maps_water_layer(target_outline, stream_order = 2, fast = T, 
                     basin_or_zone = all_targets[[i]][j])}
    if (i == 3){maps_water_layer(target_outline, stream_order = 2, fast = T, 
                     region = all_targets[[i]][j])}
    
    #run the inset map function
    maps_inset_layer(supplied_sf_1 = target_outline, background = target_region, aspect = 0.9)
    
    for (k in unique(target_data$Year)){#and for each of the Years present in the data
      
      #select only one year
      target_data_one_year <- target_data |> filter(Year == k)

      #create the map (don't forget to add the custom water layer)
      map <- tm_shape(qld) +
        tm_polygons(fill = "grey80", 
                    col = "black") +
        tm_shape(target_region) +
        tm_polygons(fill = "grey90", 
                    col = "black") +
        tm_shape(target_data_one_year, is.main = T) +
        tm_fill(fill = "Palette") +
        tm_add_legend(type = "polygons", 
                      fill = unique(target_data_one_year$Palette), 
                      labels = unique(target_data_one_year$Landuse),
                      title = "Land Use") +
        water_map +
        tm_shape(target_outline) +
        tm_borders(col = "black") +
        tm_layout(legend.frame = T, 
                  legend.bg.color = "White", 
                  legend.text.size = 0.7, 
                  legend.position = c("left", "bottom"),
                  asp = 1.1)
      
      
      #save the map as a png
      tmap_save(map, filename = glue("{output_path}/maps/{unique(target_region$Region)}/{all_targets[[i]][j]}_{names(all_targets[i])}_{k}_land-use.png"),
                insets_tm = inset_map, insets_vp = inset_viewport)

    }
  }
}

```

As an example of what one of these maps looks like, see below:

```{r}
#| label: show the maps

map

```

## Mapping Land Use Change

Generally, it is equally important to understand not only what the current or historical landuse is, but also how the landuse has changed over time. Below we present a method to calculate land use change between years of data. This method has been converted into a function that can work for any dataset of similar structure, i.e. has a year aspect, and whose value are categorical classifications.

The logic used to conduct this comparison is straight forward to understand, but requires lengthy explanation:

Assume a hypothetical situation with the following area and division of land use types.

```{r}
#| label: show image 1
#| output: true

knitr::include_graphics("/references/images/n3_climate_land-use/before_after_image_1.png", error = F, rel_path = F)

```

In this example we know the type of landuse each polygon represents, as well as the total area of each polygon. We can assign colours to the polygons and create maps. This represents how we currently understand and can inspect our data.

For the same area, a length of time passes, and the area and division of land use types changes.

```{r}
#| label: show image 2
#| output: true

knitr::include_graphics("/references/images/n3_climate_land-use/before_after_image_2.png", error = F, rel_path = F)

```

Once again, in this example we know the type of landuse each polygon represents, as well as the total area of each polygon. We can assign colours to the polygons and create maps. We can also compare the metadata we have about each of the datasets (such as the area) and create tables and plots summarizing any changes found. By looking at the tables below each map I hope that is intuitive.

However, imagine trying to answer the following questions:
1. Where in this map did forestry increase?
2. Does the increase in forestry overshadow a decrease in forestry somewhere else?
3. Why has agriculture not changed, even though we can visually see it has?

Answers:
1. In this example we could point at the map and say "there", but imagine trying to do this for a whole basin.
2. We have no way to answer this at all
3. We have not way to prove if it has changed even if we can see it has.

```{r}
#| label: show image 3
#| output: true

knitr::include_graphics("/references/images/n3_climate_land-use/before_after_image_3.png", error = F, rel_path = F)

```

To fix this, we need to rasterise the data. Essentially, convert the polygon (points and lines) into a grid of cells. What this allows us to do first of all, is introduce a standardised frame of reference (the grid). We can also use the different structure of the data to store information about the type of landuse as a number, each unique landuse is given a number from 1 to n unique landuses, and a table is created to decode those numbers later on. (In the real application of this method the grid will be of much greater resolution).

```{r}
#| label: show image 4
#| output: true

knitr::include_graphics("/references/images/n3_climate_land-use/before_after_image_4.png", error = F, rel_path = F)

```

Once we rasterise both data sets what this then allows us to do is "raster math". Where we compare each cell between each dataset and do simple addition or subtraction (side note, almost any standard equations can be applied using this method btw). The result in the cell can tell us if things changed or not. Zero would mean things haven't changed, anything other than zero means there has been a change:

```{r}
#| label: show image 5
#| output: true

knitr::include_graphics("/references/images/n3_climate_land-use/before_after_image_5.png", error = F, rel_path = F)

```

We can combine this knowledge to be able to answer questions such as where things changed and where things stayed the same. However this is not the final solution, imagine a scenario in which a conservation cell changed to an agriculture cell, and a second agriculture cell changed to a forestry cell. Each of these cells would have a value of "+1" (or -1 depending on how you math) - indicating that the cell has changed. However the actual land use that changed was different.

To address this, the second rasterise dataset does not get assigned the numbers 1-n like the first dataset does. Instead, numbers are assigned using the following equation: 

for i in n:

x = i*n+1

Where n is the total number of unique landuse types,
and i is a vector from 1 to n (i.e, 1,2,3,4,5,6..., n)

What this allows us to do, is calculate a unique final cell value for every single combination of landuse changes that may occur:

```{r}
#| label: show image 6
#| output: true

knitr::include_graphics("/references/images/n3_climate_land-use/before_after_image_6.png", error = F, rel_path = F)

```

This allows us to finally answer all of the questions asked earlier.

A custom function has been written below to do the leg work of this analysis. And a simple wrapper to run the function for each of our sub basins.

For this analysis we are going to compare the 1999 data against the 2021 data.

```{r}
#| label: create change use dataframe

#load in the custom function used to compare the data
source(here("functions/before_after_comparison.R"))

#run the comparison function
change_in_use <- before_after_comparison(dataset = n3_land_use_grouped, target_column = "Landuse", 
                                         start_year = min(n3_land_use_grouped$Year), 
                                         end_year = max(n3_land_use_grouped$Year))

```

In the case of landuse, we end up with 64 unique "change possibilities", (which are the cross cases of the 8 land uses times the 8 land uses (e.g. Grazing to Conservation)). Although useful in tabular form, trying to create a map with 64 unique classifications is not the best idea, so below we create some maps focusing on the changes that most interest us, specifically for:

- Urban/Intensive
    + divided more specifically into:
        * Urban to urban (colour = W) (No Change to Urban)
        * Urban to anything not urban (colour = X) (Loss of Urban)
        * Anything not urban to urban (colour = Y) (Gain of Urban)
        * Anything that is not urban in either dataset (colour = Z) (Not Urban)
        
- Conservation
    + divided more specifically into:
        * Conservation to conservation (colour = W) (No Change to conservation)
        * Conservation to anything not conservation (colour = X) (Loss of conservation)
        * Anything not conservation to conservation (colour = Y) (Gain of conservation)
        * Anything that is not conservation in either dataset (colour = Z) (Not conservation)

```{r}
#| label: create two map specific datasets

#create an urban change focus table and assign colours
#x(?!Urban/Intensive) means "x not followed by thing in brackets"
#(?<=Urban/Intensive)x means "x not preceded by thing in brackets"
urban_use <- change_in_use |> 
      mutate("Change" = case_when(str_detect(ValueChange, "urban/intensive to urban/intensive") ~ "No Change",
                                  str_detect(ValueChange, "uUrban/intensive to (?!urban/intensive\\b).*") ~ "Loss",
                                  str_detect(ValueChange, "(?<!urban/intensive) to urban/intensive") ~ "Gain",
                                  T ~ "Other Use"),
             "Palette" = case_when(Change == "No Change" ~ "#FFFF00",
                                   Change == "Loss" ~ "#277402",
                                   Change == "Gain" ~ "#FF0000",
                                   Change == "Other Use" ~ "#A6A6A6"))

conservation_use <- change_in_use |> 
      mutate("Change" = case_when(str_detect(ValueChange, "conservation to conservation") ~ "No Change",
                                  str_detect(ValueChange, "conservation to (?!conservation\\b).*") ~ "Loss",
                                  str_detect(ValueChange, "(?<!conservation) to conservation") ~ "Gain",
                                  T ~ "Other Use"),
             "Palette" = case_when(Change == "No Change" ~ "#FFFF00",
                                   Change == "Loss" ~ "#FF0000",
                                   Change == "Gain" ~ "#277402",
                                   Change == "Other Use" ~ "#A6A6A6"))

```

```{r}
#| label: map urban and conservation land types

#load in a custom function to create the water layer (this may be a reload depending on if previous mapping chunk was run)
source(here("functions/maps_water_layer.R"))
source(here("functions/maps_inset_layer.R"))

#start mapping loop
for (i in 1:length(all_targets)){#for the number of vectors that are in the list (3)

  for (j in 1:length(all_targets[[i]])){#and for the number of variables that are in the vector
    
    #get the outline of the general area we are focused on
    target_outline <- n3_land |> filter(!!sym(names(all_targets[i])) == all_targets[[i]][j])
    
    #figure out the wider region in which the target is within
    target_region <- n3_land |> filter(Region == unique(target_outline$Region))
      
    #create a folder to store outputs at a regional level
    dir.create(glue("{output_path}/maps/{unique(target_region$Region)}/"))
      
    #run the custom water map function, pick which method based on if its region, basin, or sub basin
    if (i == 1){maps_water_layer(target_outline, stream_order = 2, fast = T, 
                     sub_basin_or_sub_zone = all_targets[[i]][j])}
    if (i == 2){maps_water_layer(target_outline, stream_order = 2, fast = T, 
                     basin_or_zone = all_targets[[i]][j])}
    if (i == 3){maps_water_layer(target_outline, stream_order = 2, fast = T, 
                     region = all_targets[[i]][j])}
    
    #set some variables to swap between
    data_focus <- c("urban_use", "conservation_use")
    
    for (k in 1:length(data_focus)){
    
      #specify both the column to filter on, and the variable to look for
      target_data <- get(data_focus[k]) |> filter(!!sym(names(all_targets[i])) == all_targets[[i]][j])
      
      #get a nice version of the data we are focusing on
      data_title <- str_to_title(str_replace_all(data_focus, "_", " "))
      
      #run the inset map function
      maps_inset_layer(supplied_sf_1 = target_outline, background = target_region, aspect = 0.9)

      #create the map (dont forget to add the custom water layer)
      map <- tm_shape(qld) +
        tm_polygons(fill = "grey80", 
                    col = "black") +
        tm_shape(target_region) +
        tm_polygons(fill = "grey90", 
                    col = "black") +
        tm_shape(target_data, is.main = T) +
        tm_fill(fill = "Palette") +
        tm_add_legend(type = "polygons", 
                      fill = unique(target_data$Palette), 
                      labels = unique(target_data$Change),
                      title = glue("{data_title[k]} Change")) +
        water_map +
        tm_shape(target_outline) +
        tm_borders(col = "black") +
        tm_layout(legend.frame = T, 
                  legend.bg.color = "White", 
                  legend.text.size = 0.7, 
                  legend.position = c("left", "bottom"),
                  asp = 1.1) +
        tm_add_legend(type = "lines", 
                      col = "dodgerblue", 
                      lwd = 2,
                      labels = "Watercourses")
      
        #save the map as a png
        tmap_save(map, filename = glue("{output_path}/maps/{unique(target_region$Region)}/{all_targets[[i]][j]}_{names(all_targets[i])}_{data_focus[k]}.png"),
                  insets_tm = inset_map, insets_vp = inset_viewport)
    }
  }
}

```

## Plot Land Use

The other visualisation that is useful to gain perspective on land use in each basin is to plot the most up to date land use in a stacked bar chart.

```{r}
#| label: land use graphs

#convert proportion of total and year to numeric
n3_land_use_final <- n3_land_use_final |> mutate(LanduseProportionOfTotalPercent = as.numeric(LanduseProportionOfTotalPercent),
                                                 Year = as.numeric(Year))

#assign names to my palette so ggplot can colour everything correctly
names(my_palette) <- unique(n3_land_use$Landuse)

for (i in basin_targets){
  
  #select a specific basin and the latest year
  basin_plot <- n3_land_use_final |> filter(BasinOrZone == i, Year == 2021) |> 
    arrange(desc(LanduseProportionOfTotalPercent)) |> 
    mutate(Landuse = factor(Landuse, levels = unique(Landuse)))
  
  #create a plot
  plot <- ggplot(basin_plot, aes(fill = Landuse, x = Year, y = LanduseProportionOfTotalPercent)) +
    geom_bar(position = position_fill(reverse = T), stat = "identity") +
    scale_fill_manual(values = my_palette) +
    scale_x_discrete(expand = c(0.025, 0)) +
    scale_y_continuous(expand = c(0, 0), labels = scales::percent_format(accuracy = 1)) +
    labs(x = "", y = "", fill = glue("{i} Basin Land Use")) +
    theme(axis.text.x = element_text(colour = "black"),
          axis.text.y = element_blank(),
          axis.line.x = element_line(colour = "black"),
          axis.ticks.length = unit(-0.15, "cm"),
          panel.background = element_blank()) +
    coord_flip()
  
  #save
  ggsave(glue("{output_path}/plots/{i}_land-use.png"), plot, width = 12, height = 4)
}



```

After running and saving all of these see below for an example.

```{r}
#| label: show the plot

plot

```





